[[creating-a-soap-client]]
= Creating a SOAP Client

Quarkus-CXF supports SOAP clients out of the box. Assuming a given SEI like `FruitWebService` is present, Quarkus-CXF
is able to inject a ready-to-go configured SOAP client:

[source,java]
----
import java.lang.reflect.Proxy;
import javax.annotation.PostConstruct;
import javax.inject.Inject;
import javax.enterprise.context.ApplicationScoped;
import org.junit.jupiter.api.Assertions;

import com.example.FruitWebService;

@ApplicationScoped    // or any other CDI scope
public class MySoapClient {

    @Inject
    FruitWebService client; // injects proxy client to service

    @PostConstruct
    void postConstruct() {
        Assertions.assertTrue(Proxy.isProxyClass(client));
    }

    public int getCount() {
        return client.count();
    }
}
----

Without any configuration given Quarkus-CXF assumes a service to be published at
`http://localhost:8080/{service-path}`, where `{service-path}` in turn is derived
from config property `quarkus.cxf.path` (if present) and the SEI's full class name
in lowercase characters. Thus in the example above Quarkus-CXF assumes service
FruitWebService to be published at `http://localhost:8080/com.example.fruitwebservice`.

It is of course possible to configure SOAP clients:

[source,properties]
----
quarkus.cxf.client."my-fruitservice-client".service-interface=com.example.FruitWebService      # (A)
quarkus.cxf.client."my-fruitservice-client".client-endpoint-url=http://localhost:8080/fruit    # (B)
----

Here a logical client configuration named `my-fruitservice-client` is created. Line (A) defines
the SEI while (B) defines the URL where this service is expected to be published. Quarkus-CXF produces a
SOAP client by scanning for applicable client configurations. A client configurations matches if
config property `.service-interface` matches the qualified SEI name and is not marked as configuration
alternative.

Quarkus-CXF allows you to have more than one client configuration per SEI:

[source,properties]
----
quarkus.cxf.client."my-fruitservice-client".service-interface=com.example.FruitWebService               # (A)
quarkus.cxf.client."my-fruitservice-client".client-endpoint-url=http://localhost:8080/fruit             # (B)

quarkus.cxf.client."my-featured-fruitservice-client".service-interface=com.example.FruitWebService      # (C)
quarkus.cxf.client."my-featured-fruitservice-client".client-endpoint-url=http://localhost:8080/fruit    # (D)
quarkus.cxf.client."my-featured-fruitservice-client".features=org.apache.cxf.feature.LoggingFeature     # (E)
----

Here another client configuration named `my-featured-fruitservice-client` has been defined in addition to
`my-fruitservice-client`. This configuration adds, as an example, a standard CXF logging feature which can
be useful for tracing or debugging.

Adding this second configuration created an ambiguity though:

[source,java]
----
import javax.inject.Inject;
import com.example.FruitWebService;

@Inject
FruitWebService clientService;   // with or without logging feature enabled?
----

Shall the configuration `my-featured-fruitservice-client` or `my-fruitservice-client` be used? From
Quarkus-CXF's point of view both are configurations are equivalent. There are two solutions for this
problem.

The first and arguable easiest one is to use qualifier `@Named` where the annotation value is literally
taken as a client configuration key:

[source,java]
----
import javax.inject.Inject;
import javax.inject.Named;
import com.example.FruitWebService;

@Inject
@Named("my-featured-fruitservice-client")
FruitWebService clientService;   // ok, inject featured client
----

Specifying a non existing client configuraton key is illegal. Quarkus-CXF is otherwise rather
tolerant in applying a client configuration. Technically it just applies the configuration identified by
`@Named`, regardless of whether it fits with the SEI at the injection point or not.


The second solution is to avoid `@Named` and instead _hide_ all ambigious client configurations by either

* applying property `*.alternative = true` ; or by
* removing property `*.service-interface`

as shown here:
[source,properties]
----
# quarkus.cxf.client."my-fruitservice-client".service-interface=com.example.FruitWebService
quarkus.cxf.client."my-fruitservice-client".client-endpoint-url=http://localhost:8080/fruit

quarkus.cxf.client."my-featured-fruitservice-client".client-endpoint-url=http://localhost:8080/fruit
quarkus.cxf.client."my-featured-fruitservice-client".features=org.apache.cxf.feature.LoggingFeature
----

Now client configuration my-fruitservice-client is no longer taken into acount when scanning for
a matching configuration and consequently, the featured configuration gets applied:
[source,java]
----

    @Inject
    FruitWebService clientService;   // ok, inject featured client
----



Quarkus-CXF allows you also to inject a SEI's implementation:

[source,java]
----
    @Inject
    @CXFImpl
    FruitWebService clientService;

    Assertions.assertFalse(Proxy.isProxyClass(clientService.getClass());
----

Here annotation `@CXFImpl` indicates to inject the implementation instead of client proxy. Of course this injection
works only if a webservice implementation of SEI FruitWebService is around. Quarkus-CXF adds annotation @CXFImpl
automatically on each @WebService annotated class as well as marking such a class as bean.

[[basic-auth]]
== Basic Auth

Basic auth for clients is supported by default. Just add the following properties to your `application.properties` file:

[source,properties]
----
quarkus.cxf.client."my-fruitservice-client".username=user
quarkus.cxf.client."my-fruitservice-client".password=password
----

[[async-support]]
== Asynchronous Client HTTP Transport

By default, the CXF client uses `HttpURLConnection` to perform HTTP requests.  In order to have non-blocking (asynchronous) invocations you can add the  `cxf-rt-transports-http-hc` dependency to your project.

Once the dependency is available in the classpath, CXF will use `HttpAsyncClient` for asynchronous calls and will continue using `HttpURLConnection` for synchronous calls.

You can see more details about the CXF asynchronous client and how to tune it further at https://cxf.apache.org/docs/asynchronous-client-http-transport.html[this link].